# Sysprog

OSよりの知識メモ

[参考](https://ascii.jp/serialarticles/1235262/)

## プロセス・スレッド

- プロセス: プログラムの実行単位
  - 静的メモリやスタック、ヒープ領域、レジスタなどのリソースを保持する。
  - 他のプロセスのリソースには干渉せず独立している。
  - プロセス間の切り替えのオーバーヘッドは大きい。
- スレッド: プロセス内の実行単位
  - プロセス内で生成されプロセスが持つリソースを使用する。
  - マルチスレッドの場合プロセスのリソースをスレッド間で共有する。
  - スレッドの切り替えはオーバーヘッドは少ない。
- ゴルーチン: Go特有の概念
  - スレッドに近い存在。
  - スレッドよりも軽量である。
  - ゴルーチンの切り替えは、OSのスケジューラではなくGoのランタイムが管理する。

## OSの機能

- 各種資源の管理
  - メモリ
  - CPU時間
  - ストレージ
- 外部入出力機能の提供
  - ネットワーク
  - ファイル読み書き
  - プロセス間通信

## io.Writer

- `Write(p []byte) (n int, err error)`を持つ。
- Posix系OSでは全ての入出力の対象をファイルとして扱う。ファイルの識別番号のことをファイルディスクリプタ(fd)という。
- デフォルトでは、１プロセスあたりカーネル内に3つの擬似ファイルが生成され、1~3のfdが割り当てられる。
  - 1: 標準出力
  - 2: 標準入力
  - 3: 標準エラー出力
- 新たにソケットがオープンしたり、ファイルが開かれたりすると順番にfdが割与えられる。
- ファイルに対する書き込みはシステムコールのwriteで行われる。
  - しかし、OSによってシステムコールの仕様が少し違うため、Goでは抽象化されたio.Writerが存在する。
  - io.Writerはインターフェース
- io.Writerを満たす型の例
  - os.File
  - os.Stdout
  - bytes.Buffer
  - net.Conn(インターフェース)
    - net.TCPConn
    - net.UDPConn

## io.Reader

- `func Read(p []byte) (n int, err error)`を持つ。
  - p は、読み込んだ内容を一時的に入れておくバッファ
- io.Readerを満たす型の例
  - os.Stdin
  - os.File
  - net.Conn
  - bytes.Buffer
- 外部からの入力を外部へ出力するまでのデータの流れを扱うパイプのことをストリームという。
  - io.Writerやio.Writerなどを使用して、独自のストリームを組み立てることができる。
- その他の便利なio.Reader
  - io.LimitReader: 先頭から特定のバイトまでしか読み込まない。
  - io.SectionReader: PNGなど、バイナリがチャンク(データの塊)に別れている際などに便利。
  - binary.Read: エンディアン変換する時に使う。現代のCPUはリトルエンディアンだが、サーバーなどはビッグエンディアンの物も多い。

## システムコール

　CPUの動作モードとして、特権モードとユーザモードがある。特権モードではCPUのメモリをフルで使うことができるが、
ユーザモードではメモリの書き込みや実行に制限がある。

　OSは特権モードでCPUを扱うことができるが、アプリケーションはユーザモードで実行される。
アプリケーション側で特権モードの機能を使用したい時にシステムコールのでOSの機能を呼び出す。
x86系CPUではSYSCALL,SYSRET命令が使われ、ARM系ではSVC命令が使われる。

　ユーザ権限(システムコールを使用しない場合)でもCPUのSIMD系の命令が使えるため、計算処理自体は可能。
しかし、他プロセスに割り当てられたリソースや共有メモリに処理結果を書き込むことができないため、画面やファイルに結果を反映できない。
そのため、システムコールで特権モードの機能を呼び出す必要性がある。

| システムコール関数                                    | 機能                                       |
| ----------------------------------------------------- | ------------------------------------------ |
| func syscall.Open(path string, mode int, perm uint32) | ファイルを開く（作成も含む）               |
| func syscall.Read(fd int, p []byte)                   | ファイルから読み込みを行う                 |
| func syscall.Write(fd int, p []byte)                  | ファイルに書き込みを行う                   |
| func syscall.Close(fd int)                            | ファイルを閉じる                           |
| func syscall.Seek(fd int, offset int64, whence int)   | ファイルの書き込み／読み込み位置を移動する |

## POSIX

　IEEEが定めた、OS間が持つべきシステムコールを定めた規格。
open()、read()、write()、close()、lseek()の５つのシステムコールが定義されている。
この規格を満たしたOSをPOSIX準拠したOSと呼べる。

## ソケット通信

アプリケーション(OS上のプログラム)開発ではトランスポート層以上を意識しとけばいい。
プロトコルの詳細はRFCを参照する。

| レイヤ                         | プロトコル     | 担当者                                                        |
| ------------------------------ | -------------- | ------------------------------------------------------------- |
| アプリケーション層             | HTTP           | アプリケーション                                              |
| トランスポート層               | TCP,UDP,QUIC   | OSが担当だが、アプリケーションもソケットAPIを通じて触れられる |
| ネットワーク層                 | IP             | OS                                                            |
| ネットワークインターフェース層 | Wi-Fi,Ethernet | ハードウェア                                                  |

- HTTPを応用したプロトコル(HTTP上で使用する)

  - RPC (JSON-RPC,XML-RPC)
  - REST
  - GraphQL

- HTTP/1.0とHTTP/1.1の違い

  - TCPでは、接続・切断にそれぞれ1.5RTTかかるため、やり取りごとに接続・切断を繰り返すのは効率が悪い。
  - HTTP/1.1ではKeep-Aliveで設定された時間の間は、セッションを使いまわすため、効率がよくなっている。

- ソケット(BSDソケット)とは？

  - OSが提供するIPC(プロセス間通信)の機能として、シグナル、メッセージキュー、パイプ、共有メモリなどがある。
  - ソケットもIPCの内の一種。アドレスとポートが分かれば遠隔のプロセスと通信することができる点が他と異なる。
  - アプリケーションがトランスポート層を利用する際のインターフェースとして使用される。

- ソケットの利用方法(TCPの例)
  - サーバはListen()でソケット開いて待ち受ける
  - クライアントはDial()でソケットに接続する。
  - 通信の確立方法はプロトコルによって異なる。TCPの場合、サーバ側でクライアントをAccept()することで確立する。
  - Close()で通信を切断する。

### TCP

- 特徴

  - 再送制御:
    - パケットに含まれるシーケンス番号を元に受け取り側が組み立てる。組み立てに必要なデータが揃ってる場合、確認応答をする。
    - 受け手側からの確認応答がない場合、送り手は再度パケットを送り直す。
  - ウィンドウ制御:
    - コネクション確立時にウィンドウと呼ばれる送受信用のバッファが作成される。
    - 送り手はウィンドウサイズの範疇でデータを一方的に送りつけることができる。
    - 受け取り側がウィンドウの読み取りに間に合わない場合、ウィンドウサイズを小さくし、パケット送信量を制限する。

- パフォーマンス向上の工夫
  - 圧縮: gzip圧縮がよく使われる。
    - 通信量を抑える->通信にかかる時間も削減できる。
    - クライアントはAccept-Encodingヘッダをセット
    - サーバはContent-Encodingヘッダをセット
  - ボディをチャンク化
    - やり取りするデータをチャンクに細切れにして少しづつ送受信する。
    - 大容量のデータなどの場合、メモリにまとめてロードする必要がないため効率Up。
    - サーバはTransfer-Encodingヘッダをセット。
  - パイプライニング
    - 通信の非同期化による高速化。
    - レスポンスがくる前に次から次にリクエストを多重で飛ばす。

### UDP

- TCPと違いコネクションレスなので、ハンドシェイクによる1.5RTTのロスがない。
  - TCPのような輻輳制御や誤り検出がなく、データは一方的に送り続けるのみ。
- マルチキャストをサポートしている。
- 動画ストリーミングにおけるWebRTCの土台としてよく使われる。
- 機能が少ないため、独自プロトコルを開発する際のベースとしても使われる。

- マルチキャスト

  - 複数のクライアントに同時送信できる。
  - 一つのマルチキャストアドレスが予約されており、送信者はそこに送信するのみ。
  - マルチキャストアドレスに登録された複数のクライアントをグループという。
  - IPv4では1110で始まるアドレスが予約されている。ローカルの場合は224.0.0.0~224.0.0.255。

- 実装面における違い

  - TCPと違い、UDPではクライアントがソケットを開いてパケットを待ち受ける。
  - サーバは一方的にパケットを送りつけるのみ。
  - TCPではサーバがリクエストを待ち受けるため、サーバとクライアントの実装が逆になる。

- デメリット
  - 1.大きなデータの送受信に向かない
    - IPで定義された、ネットワークインターフェース(ethernet,wifi)ごとの、経路内での最大転送単位をMTUという。
    - MTU以上のパケットはIP層で分割され、のちに組み立て直される。これをIPフラグメンテーションという。
    - UDPでMTUを超えるフレームのパケットを送る場合、IPフラグメンテーションによるオーバーヘッドが生じるため、高速性が損なわれてしまう。
  - 2.他の通信のパフォーマンスに悪影響を与える可能性がある。
    - TCPには輻輳制御が備わっており、通信路全体での輻輳(渋滞)を抑える機能がある。これによってフェアネスが保たれる。
    - 一方、UDPにこのような機能は備わっておらず、ネットワークの混雑を招く可能性がある。

### HTTP/2とQUIC

　TCP上で動くHTTP/2の、共通部分を統合し、さらにTCPをUDPに置き換えたプロトコルをQUICという。

### Unixドメインソケット

　上記のBSDソケットの応用。TCP/UDPで使用する通常のソケットはネットワークを通じて、外部ホストとの通信に用いた。
しかし、UnixドメインソケットはOSのファイルシステム上で、カーネル内で通信をすることに使う。

BSDソケットではIPアドレスとポートでソケットを指定したが、Unixドメインソケットの場合はファイルパスで指定する。
BSDソケットと比べて高速。

ソケットのインターフェースとしてファイルを使用する。コネクション確立時はソケットファイルというファイルが生成される。

- モード
  - ストリーム型(TCP型): サーバ・クライアント間でコネクションを確立する。
  - データグラム型(UDP型): コネクションは作成されず、一方的にデータグラムを送りつける。
